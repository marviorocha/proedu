{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(factory);\n  } else if ((typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like enviroments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.Sparkline = factory();\n  }\n})(window, function () {\n  function extend(specific, general) {\n    var obj = {};\n\n    for (var key in general) {\n      obj[key] = key in specific ? specific[key] : general[key];\n    }\n\n    return obj;\n  }\n\n  function Sparkline(element, options) {\n    this.element = element;\n    this.options = extend(options || {}, Sparkline.options);\n\n    init: {\n      this.element.innerHTML = \"<canvas></canvas>\";\n      this.canvas = this.element.firstChild;\n      this.context = this.canvas.getContext(\"2d\");\n      this.ratio = window.devicePixelRatio || 1;\n\n      if (this.options.tooltip) {\n        this.canvas.style.position = \"relative\";\n        this.canvas.onmousemove = showTooltip.bind(this);\n      }\n    }\n  }\n\n  Sparkline.options = {\n    width: 100,\n    height: null,\n    lineColor: \"black\",\n    lineWidth: 1.5,\n    startColor: \"transparent\",\n    endColor: \"black\",\n    maxColor: \"transparent\",\n    minColor: \"transparent\",\n    minValue: null,\n    maxValue: null,\n    minMaxValue: null,\n    maxMinValue: null,\n    dotRadius: 2.5,\n    tooltip: null,\n    fillBelow: true,\n    fillLighten: 0.5,\n    startLine: false,\n    endLine: false,\n    minLine: false,\n    maxLine: false,\n    bottomLine: false,\n    topLine: false,\n    averageLine: false\n  };\n\n  Sparkline.init = function (element, options) {\n    return new Sparkline(element, options);\n  };\n\n  Sparkline.draw = function (element, points, options) {\n    var sparkline = new Sparkline(element, options);\n    sparkline.draw(points);\n    return sparkline;\n  };\n\n  function getY(minValue, maxValue, offsetY, height, index) {\n    var range = maxValue - minValue;\n\n    if (range == 0) {\n      return offsetY + height / 2;\n    } else {\n      return offsetY + height - (this[index] - minValue) / range * height;\n    }\n  }\n\n  function drawDot(radius, x1, x2, color, line, x, y) {\n    this.context.beginPath();\n    this.context.fillStyle = color;\n    this.context.arc(x, y, radius, 0, Math.PI * 2, false);\n    this.context.fill();\n    drawLine.call(this, x1, x2, line, x, y);\n  }\n\n  function drawLine(x1, x2, style, x, y) {\n    if (!style) return;\n    this.context.save();\n    this.context.strokeStyle = style.color || 'black';\n    this.context.lineWidth = (style.width || 1) * this.ratio;\n    this.context.globalAlpha = style.alpha || 1;\n    this.context.beginPath();\n    this.context.moveTo(style.direction != 'right' ? x1 : x, y);\n    this.context.lineTo(style.direction != 'left' ? x2 : x, y);\n    this.context.stroke();\n    this.context.restore();\n  }\n\n  function showTooltip(e) {\n    var x = e.offsetX || e.layerX || 0;\n    var delta = (this.options.width - this.options.dotRadius * 2) / (this.points.length - 1);\n    var index = minmax(0, Math.round((x - this.options.dotRadius) / delta), this.points.length - 1);\n    this.canvas.title = this.options.tooltip(this.points[index], index, this.points);\n  }\n\n  Sparkline.prototype.draw = function (points) {\n    points = points || [];\n    this.points = points;\n    this.canvas.width = this.options.width * this.ratio;\n    this.canvas.style.width = this.options.width + 'px';\n    var pxHeight = this.options.height || this.element.offsetHeight;\n    this.canvas.height = pxHeight * this.ratio;\n    this.canvas.style.height = pxHeight + 'px';\n    var lineWidth = this.options.lineWidth * this.ratio;\n    var offsetX = Math.max(this.options.dotRadius * this.ratio, lineWidth / 2);\n    var offsetY = Math.max(this.options.dotRadius * this.ratio, lineWidth / 2);\n    var width = this.canvas.width - offsetX * 2;\n    var height = this.canvas.height - offsetY * 2;\n    var minValue = Math.min.apply(Math, points);\n    var maxValue = Math.max.apply(Math, points);\n    var bottomValue = this.options.minValue != undefined ? this.options.minValue : Math.min(minValue, this.options.maxMinValue != undefined ? this.options.maxMinValue : minValue);\n    var topValue = this.options.maxValue != undefined ? this.options.maxValue : Math.max(maxValue, this.options.minMaxValue != undefined ? this.options.minMaxValue : maxValue);\n    var minX = offsetX;\n    var maxX = offsetX;\n    var x = offsetX;\n    var y = getY.bind(points, bottomValue, topValue, offsetY, height);\n    var delta = width / (points.length - 1);\n    var dot = drawDot.bind(this, this.options.dotRadius * this.ratio, offsetX, width + offsetX);\n    var line = drawLine.bind(this, offsetX, width + offsetX);\n    this.context.save();\n    this.context.strokeStyle = this.options.lineColor;\n    this.context.fillStyle = this.options.lineColor;\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = 'round';\n    this.context.lineJoin = 'round';\n\n    if (this.options.fillBelow && points.length > 1) {\n      this.context.save();\n      this.context.beginPath();\n      this.context.moveTo(x, y(0));\n\n      for (var i = 1; i < points.length; i++) {\n        x += delta;\n        minX = points[i] == minValue ? x : minX;\n        maxX = points[i] == maxValue ? x : maxX;\n        this.context.lineTo(x, y(i));\n      }\n\n      this.context.lineTo(width + offsetX, height + offsetY + lineWidth / 2);\n      this.context.lineTo(offsetX, height + offsetY + lineWidth / 2);\n      this.context.fill();\n\n      if (this.options.fillLighten > 0) {\n        this.context.fillStyle = 'white';\n        this.context.globalAlpha = this.options.fillLighten;\n        this.context.fill();\n        this.context.globalAlpha = 1;\n      } else if (this.options.fillLighten < 0) {\n        this.context.fillStyle = 'black';\n        this.context.globalAlpha = -this.options.fillLighten;\n        this.context.fill();\n      }\n\n      this.context.restore();\n    }\n\n    x = offsetX;\n    this.context.beginPath();\n    this.context.moveTo(x, y(0));\n\n    for (var i = 1; i < points.length; i++) {\n      x += delta;\n      this.context.lineTo(x, y(i));\n    }\n\n    this.context.stroke();\n    this.context.restore();\n    line(this.options.bottomLine, 0, offsetY);\n    line(this.options.topLine, 0, height + offsetY + lineWidth / 2);\n    dot(this.options.startColor, this.options.startLine, offsetX + (points.length == 1 ? width / 2 : 0), y(0));\n    dot(this.options.endColor, this.options.endLine, offsetX + (points.length == 1 ? width / 2 : width), y(points.length - 1));\n    dot(this.options.minColor, this.options.minLine, minX + (points.length == 1 ? width / 2 : 0), y(points.indexOf(minValue)));\n    dot(this.options.maxColor, this.options.maxLine, maxX + (points.length == 1 ? width / 2 : 0), y(points.indexOf(maxValue))); //line(this.options.averageLine, )\n  };\n\n  function minmax(a, b, c) {\n    return Math.max(a, Math.min(b, c));\n  }\n\n  return Sparkline;\n});","map":null,"metadata":{},"sourceType":"module"}